Print Farm OS - Project Plan
Executive Summary
Building an open-source "operations kernel" for 3D print farms that bridges e-commerce and production. This fills the gap between Klipper/Moonraker (machine control) and Shopify/Etsy (demand), providing standardized job tracking, automated pipelines, and intelligent failure prevention.
Core Architecture
Data Model (The Foundation)
Intent (Customer promise - append-only)

Order details, files, material/color/finish
SLA/due date, constraints, payment status
Immutable customer-facing truth

Plan (Manufacturing recipe - revisioned)

Slicer profile (versioned), orientation, supports
Printer requirements, post-processing steps
Each revision creates new version, never mutates

BuildPlate (Batch composition)

Groups multiple plan instances for efficiency
Handles partial success scenarios
Optional for solo mode, required for scaling

Run (Execution attempt)

Actual print on specific printer at specific time
Telemetry, anomalies, QA results
Links to evidence (photos, logs, operator notes)

Control System Components
Policy Engine (Automation governor)

Auto-advance gates (slice/dispatch/reprint)
Approval requirements based on risk
Loop breakers and retry ceilings
SLA protection rules

Risk Scoring (Decision support)

Calculated at Intent/Plan/Run stages
Risk level (LOW/MEDIUM/HIGH) + factors
Drives scheduling and approval gates
Human-readable explanations

Guardrails (Circuit breakers)

Plan loop breaker: blocks after N failures
Printer degradation detector
Quality drift signals
Auto-pause on anomaly detection

Phase 1: Minimum Viable Core (Weeks 1-6)
Week 1-2: Foundation

 Database schema for Intent/Plan/BuildPlate/Run
 Event envelope + core event types
 Artifact storage (content-addressed, S3/Minio)
 Basic state machines with reason codes
 Docker Compose single-node setup

Week 3-4: Pipeline Basics

 File upload + preflight validation

Manifold check, thin walls, bounding box
Material compatibility verification


 Manual quoting interface
 Headless slicer service (PrusaSlicer/SuperSlicer)

Profile versioning system
Deterministic slicing (container-based)


 Moonraker connector

Upload gcode, start job
WebSocket + poll fallback
Reconciliation loop



Week 5-6: Core Operations

 Job state transitions with idempotency
 Basic policy engine (fixed predicates)
 Simple risk calculation
 Plan loop breaker (2 failures = review required)
 Printer degradation detection

Deliverable: Can accept STL → validate → slice → queue → print on one printer
Phase 2: Multi-Printer Operations (Weeks 7-10)
Week 7-8: Scheduling & Batching

 Printer capabilities system

Build volume, enclosure, nozzle sizes
Material compatibility flags


 Calibration state tracking (manual entry v0)
 BuildPlate composer

Material/color grouping
Changeover cost awareness


 Basic scheduler (group by material/color/nozzle)

Week 9-10: Quality & Monitoring

 QA workflow with pass/fail states
 Photo capture integration points
 Partial success handling (per-item outcomes)
 Automatic reprint logic
 First-layer failure detection (Moonraker telemetry)

Deliverable: Can run 3-5 printers with batching and basic failure recovery
Phase 3: User Interface (Weeks 11-14)
Week 11-12: Core Screens

 Today/Triage Board (Run surface)

Attention Now / At Risk / Running / Ready for QA
One-click playbooks for common issues
Desynced printer badges


 Order/Promise (Intent surface)

Customer truth, SLA tracking
Preflight results display


 Build Plan (Plan surface)

Revision timeline with diffs
Approval workflow with impact preview



Week 13-14: Operations UI

 Plate Composer (BuildPlate surface - farm mode only)
 Risk visualization (level + factors with tooltips)
 Policy decision explanations
 Circuit breaker status displays
 Printer health dashboard

Deliverable: Full operator interface for daily farm management
Phase 4: Automation & Intelligence (Weeks 15-18)
Week 15-16: Advanced Validation

 Enhanced DFM checks

Overhang risk scoring
Support requirement estimation
Warping risk by geometry + material


 Auto-orientation suggestions
 Model repair workflow integration

Week 17-18: Anomaly Detection

 Spaghetti detection (camera + heuristics)
 Extrusion anomaly detection
 Layer adhesion monitoring
 Temperature stability tracking
 Auto-pause on confidence threshold

Deliverable: System catches 80%+ of preventable failures early
Phase 5: E-commerce Integration (Weeks 19-22)
Week 19-20: Commerce Layer

 Shopify webhook integration
 Etsy API connector
 WooCommerce plugin
 Automated pricing engine

Volume/time/material calculation
Support cost estimation


 Payment status tracking

Week 21-22: Customer Experience

 Order status webhooks
 Shipping label integration
 Customer notification system
 Public tracking page (optional)

Deliverable: Fully automated STL → shipped without manual intervention (happy path)
Phase 6: Operations Maturity (Weeks 23-26)
Week 23-24: Inventory & Traceability

 Filament spool tracking
 Material lot traceability
 Consumables management (nozzles, build plates)
 Reservation system (hold on payment vs scheduling)

Week 25-26: Analytics & Optimization

 Success rate dashboards

By printer, profile, material, operator


 SLA performance tracking
 Cost analysis (material waste, print time)
 Profile regression testing framework

Deliverable: Data-driven operations with full audit trail
Technical Stack Recommendations
Core Services

Backend: Node.js/TypeScript (or Go for performance)
Database: PostgreSQL (strong ACID, JSON support)
Message Queue: Redis (lightweight) or RabbitMQ (robust)
Object Storage: MinIO (S3-compatible, self-hosted)
Slicer: PrusaSlicer/SuperSlicer headless (containerized)

Infrastructure

Container Runtime: Docker + Docker Compose (v0)
API: REST + GraphQL for complex queries
WebSockets: Real-time printer status
Authentication: JWT with TOTP (you've built this before)

Frontend

Framework: React + TypeScript
State: React Query for server state
UI: Tailwind CSS (you're comfortable with this)
Real-time: WebSocket hooks for live updates

Integration Points
External Systems

Klipper/Moonraker (machine control)

HTTP API + WebSocket
Gcode upload, job control, telemetry


E-commerce platforms (order intake)

Webhooks for new orders
API for status updates


Cameras (monitoring - optional v0)

MJPEG/RTSP streams
Image capture API



Extension Architecture

Event bus for plugins (standardized events)
REST API for actions (create reprint, pause run)
No direct database access for extensions
Plugin registry with versioning

Success Metrics
Technical

< 5% state desync rate (Moonraker reconciliation)
< 1% duplicate job rate (idempotency working)
Profile changes deployed in < 5 minutes (rollback capability)

Operational

50%+ reduction in manual job tracking time
30%+ reduction in preventable failures
80%+ of jobs complete without human intervention (happy path)

Scaling

Support 1-50 printers on single node
< 2 second response time for UI operations
Handle 100+ concurrent jobs

Risk Mitigation
Technical Risks

Moonraker reliability: Implement robust reconciliation + offline handling
Slicer determinism: Pin versions, containerize, content-address everything
State consistency: Optimistic locking, event sourcing for audit

Adoption Risks

Too complex: Start with Solo Mode, hide BuildPlate abstraction
Over-automation: Policy engine allows manual override with reason codes
Lock-in concerns: Open-source core, standard event format for portability

Next Steps for You (Roger)
Immediate (This Week)

Set up repository structure
Design database schema (Intent/Plan/BuildPlate/Run)
Build event envelope + basic event types
Sketch API contracts (REST endpoints)

Short-term (Next 2 Weeks)

Implement file upload + storage (S3/MinIO)
Build basic preflight validation
Create headless slicer proof-of-concept
Test Moonraker connector with your existing printers

Questions to Answer

Will this be Fort Smith FDM's internal tool or a product?
Single-tenant or multi-tenant architecture?
What's your target deployment: cloud, on-prem, or hybrid?
License: MIT, GPL, or AGPL for SaaS protection?

This is a 6-month intensive project that aligns perfectly with your skills (PowerShell automation, React/Node, authentication systems, MSP-style tooling). It's also exactly the kind of "scratch your own itch" project that becomes a real business if you're dealing with these pain points.
Want me to drill into any specific phase or help you architect a particular component?